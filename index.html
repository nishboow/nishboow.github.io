<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Living City - Vent 360¬∞</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        :root {
            /* Variables dynamiques */
            --overlay-color: rgba(0, 0, 0, 0);
            --base-filter: brightness(1);
            --light-opacity: 0;
            /*--background-sky: #708193;*/
            --sky-top: #204070;
            --sky-mid: #4a7db3;
            --sky-bottom: #a8c6e3;
            --haze-opacity: 0.6;
            --haze-color: rgba(255, 255, 255, 0.3);
            --cloud-color: #ffffff;
            --snow-opacity: 0;
            
            /* --- NOUVEAU : VECTEURS DE VENT (X et Y) --- */
            /* Par d√©faut, vers la droite */
            --tx: 100vw; 
            --ty: 0px;
            --wind-duration: 60s; 
        }

        body, html { 
            margin: 0; padding: 0; 
            width: 100%; height: 100%; 
            overflow: hidden; 
            font-family: 'Inter', sans-serif; 
        }

        #scene {
            position: relative;
            width: 100vw; height: 100vh;
            overflow: hidden;
            background-color: var(--background-sky);
        }

        #background-sky {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(to bottom, var(--sky-top) 0%, var(--sky-mid) 75%, var(--sky-bottom) 100%);
            z-index: 0;
             /* Subtle grain to break up banding */
             filter: contrast(1.05) brightness(1.02);
            /*  transition: background-color 2s linear;*/
        }
        /* --- NEW LAYER FOR ATMOSPHERIC HAZE --- */
        /* This creates the bright glow near the horizon */
        #sky-haze-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; /* Same z-index as background, sits on top due to DOM order */
            /* A large radial gradient starting from bottom center */
            background-image: radial-gradient(ellipse 150% 80% at 50% 100%, var(--haze-color) 0%, transparent 70%);
            opacity: var(--haze-opacity);
            mix-blend-mode: screen; /* Helps blend light over the background */
            pointer-events: none;
            transition: opacity 5s linear, background-color 5s linear;
        }
        .shared-layer{
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: auto 120%; background-repeat: no-repeat; background-position: center;
            pointer-events: none;
            transition: opacity 5s linear; /* Transition douce pour tout le monde */
        }
        #base-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('city_base.png'); 
            background-size: auto 120%; background-repeat: no-repeat; background-position: center;
            z-index: 1;
            filter: var(--base-filter);
            transition: filter 5s linear;
        }
        /* --- D√âFINITION DES IMAGES --- */
        .snow { 
            background-image: url('city_snow.png'); 
            opacity: var(--snow-opacity, 0);
            filter: var(--base-filter);
            transition: filter 5s linear, opacity 5s linear;
        }
        .light { 
            background-image: url('lights.png'); 
            opacity: var(--light-opacity, 0);
            mix-blend-mode: normal; /* ou screen selon tes go√ªts */
            filter: brightness(1) drop-shadow(0 0 5px rgba(250,200,80,0.5));
        }
        /* --- CSS NUAGES MIS √Ä JOUR --- */
        #cloud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none; overflow: hidden;
        }

        .cloud {
            position: absolute;
            background: var(--cloud-color);
            border-radius: 100px;
            opacity: var(--cloud-opacity, 0.8);
            filter: var(--cloud-filter, blur(25px));
            
            /* L'animation utilise les vecteurs calcul√©s */
            animation: moveCloud var(--wind-duration) linear infinite;
            transition: background-color 5s, opacity 2s;
            content-visibility: auto;
        }

        /* Formes nuages */
        .cloud::after, .cloud::before {
            content: ''; position: absolute; background: inherit; border-radius: 50%;
        }
        .cloud::before { width: 50%; height: 150%; top: -60%; left: 15%; }
        .cloud::after { width: 40%; height: 120%; top: -50%; right: 15%; }

        /* --- NOUVELLE ANIMATION 360¬∞ --- */
        /* On part de l'oppos√© du vecteur (-tx, -ty) vers le vecteur (tx, ty) */
        /* Cela cr√©e une travers√©e compl√®te de l'√©cran passant par le centre */
        @keyframes moveCloud {
            from { 
                transform: translate(calc(var(--tx) * -1), calc(var(--ty) * -1)); 
            }
            to { 
                transform: translate(var(--tx), var(--ty)); 
            }
        }
        #snow-layer-back { z-index: 1; }
        #light-layer-back { z-index: 1; }
        #snow-layer-front, #light-layer-front {
            z-index: 4; 
        }
        .front-mask {
            /* On utilise l'image des tours comme pochoir */
            -webkit-mask-image: url('hauteur.png');
            mask-image: url('hauteur.png');
            
            /* Le masque doit √™tre align√© EXACTEMENT comme le background */
            -webkit-mask-size: auto 120%;
            mask-size: auto 120%;
            
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            
            -webkit-mask-position: center;
            mask-position: center;
        }

        #foreground-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('hauteur.png'); 
            background-size: auto 120%; background-repeat: no-repeat; background-position: center;
            z-index: 3;
            filter: var(--base-filter);
            transition: filter 5s linear;
            pointer-events: none;
        }
        #weather-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none;
        }

        #overlay-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--overlay-color);
            z-index: 6; pointer-events: none; mix-blend-mode: multiply; 
            transition: background-color 5s linear;
        }
        .ui-container {
            position: absolute; top: 15%; left: 50%; 
            transform: translateX(-50%); z-index: 50;
            text-align: center; color: #333;
            background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px);
            padding: 1.5rem 3rem; border-radius: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: color 1s, background 1s;
            user-select: none;
            cursor: pointer;
        }
        body.dark-ui .ui-container { color: white; background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px); }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 2px; text-transform: uppercase; opacity: 0.8; }
        .big-temp { font-size: 4rem; font-weight: 800; margin: 0; line-height: 1; }
        .status { font-size: 0.9rem; font-weight: 600; margin-top: 5px; opacity: 0.9; }

        .debug-panel {
            position: fixed; bottom: 20px; left: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px); padding: 15px;
            border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-family: sans-serif; font-size: 12px; width: 220px;
            display: none;
        }
        .debug-panel button { cursor: pointer; padding: 5px; margin: 2px; border: 1px solid #ccc; background: #eee; border-radius: 4px; }
        .debug-panel button:hover { background: #ddd; }
        .debug-panel input { width: 100%; margin: 5px 0; }
        .debug-panel.visible{
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn{
            from {opacity:0; transform: translateY(10px)}
            to {opacity: 1; transform: translateY(0) ;}
        }
    </style>
</head>
<body>

    <div id="scene">
        <div id="background-sky"></div>
        <div id="sky-haze-layer"></div>
        <div id="base-layer"></div>
        <div id="snow-layer-back" class="shared-layer snow"></div>
        <div id="light-layer-back" class="shared-layer light"></div>
        <div id="cloud-layer"></div>
        <div id="foreground-layer"></div>
        <div id="snow-layer-front" class="shared-layer snow front-mask"></div>
        <div id="light-layer-front" class="shared-layer light front-mask"></div>
        <canvas id="weather-canvas"></canvas>
        <div id="overlay-layer"></div>
        

        <div class="ui-container">
            <h1 id="city-name">PARIS</h1>
            <div class="big-temp" id="temp">--¬∞</div>
            <div class="status">
                <span id="icon">--</span>
                <span id="condition">Chargement...</span>
            </div>
        </div>
    </div>

    <div class="debug-panel">
        <strong>üïí HEURE : <span id="debug-time">R√©el</span></strong><br>
        <input type="range" id="time-slider" min="0" max="24" step="0.1">
        <button onclick="resetTime()">Reset Heure</button>
        
        <hr style="margin: 10px 0; border: 0; border-top: 1px solid #ccc;">

        <strong>‚õàÔ∏è M√âT√âO FORCE :</strong><br>
        <div style="display:flex; justify-content: space-between;">
            <button onclick="forceWeather(0)">‚òÄÔ∏è</button>
            <button onclick="forceWeather(3)">‚òÅÔ∏è</button>
            <button onclick="forceWeather(45)" title="Brume / Brouillard">üå´Ô∏è</button>
            <button onclick="forceWeather(61)">üåßÔ∏è</button>
            <button onclick="forceWeather(71)">‚ùÑÔ∏è</button>
        </div>

        <strong>üí® VITESSE : <span id="debug-wind-val">10</span> km/h</strong><br>
        <input type="range" id="wind-slider" min="0" max="120" value="10" oninput="forceWindSpeed(this.value)">

        <strong style="display:block; margin-top:5px;">üß≠ DIRECTION : <span id="debug-wind-dir-val">Ouest</span></strong>
        <input type="range" id="wind-dir-slider" min="0" max="360" value="270" oninput="forceWindDir(this.value)">
        
        <div style="margin-top:10px;">
            <button onclick="resetWeatherDebug()" style="width:100%; font-weight:bold; color:blue; border: 1px solid blue; background: #eef;">RETOUR LIVE API</button>
        </div>
    </div>

    <script>
        const CONFIG = { lat: 48.8566, lon: 2.3522, city: "PARIS" };
        let simulationOffset = null; 

        function getSunPhase(date) {
            if (typeof SunCalc === 'undefined') return 45; 
            const pos = SunCalc.getPosition(date, CONFIG.lat, CONFIG.lon);
            return pos.altitude * (180 / Math.PI); 
        }
        // 1. Outils math√©matiques pour m√©langer les couleurs
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpColor(c1, c2, t) {
            return [
                Math.round(lerp(c1[0], c2[0], t)),
                Math.round(lerp(c1[1], c2[1], t)),
                Math.round(lerp(c1[2], c2[2], t))
            ];
        }
        function rgbStr(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }
        function rgbaStr(c, a) { return `rgba(${c[0]},${c[1]},${c[2]}, ${a})`; }

        // 2. La Palette Fluide (D√©finition des √©tapes cl√©s)
        // Angle: Altitude du soleil en degr√©s
        // Sky: Couleurs du d√©grad√© ciel (Top, Mid, Bottom)
        // Haze: Couleur et opacit√© de la brume
        // Light: Opacit√© des lumi√®res de la ville (0 = √©teint, 1 = allum√©)
        // Filter: Luminosit√© globale de la ville
        const ATMOSPHERE_PALETTE = [
            { // NUIT PROFONDE (-90¬∞ √† -18¬∞)
                angle: -18,
                skyTop: [2, 4, 8],      skyMid: [7, 11, 20],    skyBottom: [16, 24, 38],
                hazeColor: [150, 180, 255], hazeOp: 0.3,
                cloudColor: [31, 34, 43], // Gris tr√®s sombre
                lightOp: 1.0,           baseBright: 0.5,        uiDark: true
            },
            { // CR√âPUSCULE NAUTIQUE (-6¬∞)
                angle: -6,
                skyTop: [22, 30, 60],   skyMid: [46, 59, 100],  skyBottom: [138, 79, 82],
                hazeColor: [150, 50, 50],   hazeOp: 0.5,
                cloudColor: [80, 90, 117], // Bleu gris
                lightOp: 0.8,           baseBright: 0.7,        uiDark: true
            },
            { // LEVER/COUCHER (0¬∞) - L'instant critique
                angle: 0,
                skyTop: [44, 62, 117],  skyMid: [196, 108, 77], skyBottom: [255, 179, 71],
                hazeColor: [255, 200, 100], hazeOp: 0.8,
                cloudColor: [255, 232, 201], // Rose/Orange nuages
                lightOp: 0.4,           baseBright: 0.8,        uiDark: false
            },
            { // GOLDEN HOUR (6¬∞)
                angle: 6,
                skyTop: [40, 70, 130],  skyMid: [100, 150, 200], skyBottom: [220, 190, 150],
                hazeColor: [255, 240, 200], hazeOp: 0.6,
                cloudColor: [255, 250, 240], // Blanc cass√©
                lightOp: 0.0,           baseBright: 1.0,        uiDark: false
            },
            { // PLEIN JOUR (15¬∞ et plus)
                angle: 20,
                skyTop: [26, 75, 140],  skyMid: [74, 138, 212], skyBottom: [159, 200, 232],
                hazeColor: [255, 255, 230], hazeOp: 0.5,
                cloudColor: [255, 255, 255], // Blanc pur
                lightOp: 0.0,           baseBright: 1.05,       uiDark: false
            }
        ];
        function updateAtmosphere() {
            let now = new Date();
            // Gestion du slider de temps (inchang√©)
            if (simulationOffset !== null) {
                now = new Date(); now.setHours(0, 0, 0, 0);
                const hours = Math.floor(simulationOffset);
                const minutes = (simulationOffset - hours) * 60;
                now.setHours(hours, minutes);
            }
            
            // 1. Calcul de l'altitude solaire
            let sunAlt = getSunPhase(now);
            
            // Bornes pour √©viter de sortir du tableau
            if (sunAlt < -18) sunAlt = -18;
            if (sunAlt > 20) sunAlt = 20;

            // 2. Trouver les deux √©tapes de la palette (Start & End)
            let startStep = ATMOSPHERE_PALETTE[0];
            let endStep = ATMOSPHERE_PALETTE[ATMOSPHERE_PALETTE.length - 1];

            for (let i = 0; i < ATMOSPHERE_PALETTE.length - 1; i++) {
                if (sunAlt >= ATMOSPHERE_PALETTE[i].angle && sunAlt <= ATMOSPHERE_PALETTE[i+1].angle) {
                    startStep = ATMOSPHERE_PALETTE[i];
                    endStep = ATMOSPHERE_PALETTE[i+1];
                    break;
                }
            }

            // 3. Calculer le facteur de progression (0.0 √† 1.0) entre ces deux √©tapes
            const range = endStep.angle - startStep.angle;
            const progress = (sunAlt - startStep.angle) / range; // 0 = d√©but √©tape, 1 = fin √©tape

            // 4. Interpolation et Application des couleurs
            const root = document.documentElement;

            // Ciel
            root.style.setProperty('--sky-top', rgbStr(lerpColor(startStep.skyTop, endStep.skyTop, progress)));
            root.style.setProperty('--sky-mid', rgbStr(lerpColor(startStep.skyMid, endStep.skyMid, progress)));
            root.style.setProperty('--sky-bottom', rgbStr(lerpColor(startStep.skyBottom, endStep.skyBottom, progress)));

            // Brume
            const currentHazeColor = lerpColor(startStep.hazeColor, endStep.hazeColor, progress);
            const currentHazeOp = lerp(startStep.hazeOp, endStep.hazeOp, progress);
            root.style.setProperty('--haze-color', rgbaStr(currentHazeColor, 0.5)); // Alpha fixe ou variable selon besoin
            root.style.setProperty('--haze-opacity', currentHazeOp);

            // Nuages & Lumi√®res
            root.style.setProperty('--cloud-color', rgbStr(lerpColor(startStep.cloudColor, endStep.cloudColor, progress)));
            root.style.setProperty('--light-opacity', lerp(startStep.lightOp, endStep.lightOp, progress));

            // Filtre de luminosit√© sur la ville
            const brightness = lerp(startStep.baseBright, endStep.baseBright, progress);
            // On garde un peu de contraste et de saturation dynamiques si on veut, sinon simple brightness
            root.style.setProperty('--base-filter', `brightness(${brightness}) contrast(1.1)`);

            // Gestion UI (On bascule simplement √† mi-chemin)
            if (endStep.uiDark && progress > 0.5 || startStep.uiDark && progress < 0.5) {
                document.body.classList.add('dark-ui');
            } else {
                document.body.classList.remove('dark-ui');
            }

            // Mise √† jour texte Debug
            if(simulationOffset !== null) {
                const h = now.getHours().toString().padStart(2,'0');
                const m = Math.floor(now.getMinutes()).toString().padStart(2,'0');
                document.getElementById('debug-time').innerText = `${h}:${m} (Alt: ${sunAlt.toFixed(1)}¬∞)`;
            }
        }

        // ================= 2. NUAGES 360¬∞ & VENT =================
        const cloudLayer = document.getElementById('cloud-layer');
        let currentCloudCount = 0;

        function updateWind(speedKmH, directionDeg) {
            // 1. Calcul de la Dur√©e (Vitesse)
            let duration = 100 - speedKmH; 
            if (duration < 20) duration = 20; 

            // 2. Calcul des Vecteurs (Direction 360¬∞)
            // L'API donne la direction d'o√π vient le vent (0=Nord, 90=Est).
            // Le mouvement va vers l'oppos√© (+180¬∞).
            // En CSS/Canvas : Y est invers√© (bas = positif), et 0¬∞ trigonom√©trique est √† droite.
            // On simplifie :
            // Si Dir=270 (Ouest) -> va vers l'Est (Droite, +X)
            // Si Dir=0 (Nord) -> va vers le Sud (Bas, +Y)
            
            // On convertit en radians pour Math.sin/cos
            // On ajoute 180 car le vent "pousse" vers l'oppos√©
            const angleRad = (directionDeg - 180) * (Math.PI / 180);
            
            // Distance arbitraire suffisante pour sortir de l'√©cran (ex: 150vmax)
            // On utilise des unit√©s relatives pour le CSS
            const dist = 150; 
            
            // Calcul : X = Sin(angle) * dist, Y = Cos(angle) * dist
            // Note : Math.sin/cos fonctionnent bien si on aligne le cercle.
            // Pour √™tre s√ªr : 
            // 0deg (Nord) -> Doit donner Y positif (Descend). Cos(0)=1. Donc Y = -Cos(angle+180) ?
            // Faisons simple : 
            // On veut le vecteur de DESTINATION.
            // Vent venant de (directionDeg). Il va vers (directionDeg + 180).
            const destAngleRad = (directionDeg + 180) * (Math.PI / 180);

            // En "coordonn√©es √©cran" (0¬∞ est en haut en m√©t√©o, mais √† droite en Math)
            // X = sin(angleMeteo), Y = -cos(angleMeteo) car Y est invers√© en CSS ?
            // Testons : 
            // Vent 270 (Ouest) -> Va vers 90 (Est). X doit √™tre positif. Sin(90)=1. OK.
            // Vent 0 (Nord) -> Va vers 180 (Sud). Y doit √™tre positif. -Cos(180) = -(-1) = 1. OK.
            
            const tx = Math.sin(destAngleRad) * dist;
            const ty = -Math.cos(destAngleRad) * dist;

            cloudLayer.style.setProperty('--wind-duration', `${duration}s`);
            cloudLayer.style.setProperty('--tx', `${tx}vmax`); // vmin/vmax couvre l'√©cran
            cloudLayer.style.setProperty('--ty', `${ty}vmax`);
        }

        function createComplexCloud() {
            const cloud = document.createElement('div');
            cloud.classList.add('cloud');
            
            // --- AJOUT POUR TRANSITION D'ENTR√âE ---
            // 1. On le cr√©e totalement transparent
            cloud.style.opacity = '0'; 
            // --------------------------------------

            const width = Math.floor(Math.random() * 750) + 150; 
            const height = Math.floor(width * (0.3 + Math.random() * 0.2)); 
            
            cloud.style.width = `${width}px`;
            cloud.style.height = `${height}px`;
            
            cloud.style.top = `${Math.random() * 160-30}%`;
            cloud.style.left = `${Math.random() * 160-30}%`;
            cloud.style.animationDelay = `-${Math.random() * 100}s`;
            
            const blur = 20 + Math.random() * 40;
            cloud.style.filter = `blur(${blur}px)`;
            
            cloudLayer.appendChild(cloud);

            // --- AJOUT POUR TRANSITION D'ENTR√âE ---
            // 2. Juste apr√®s l'avoir ajout√©, on nettoie le style inline.
            // Cela rend la main au CSS (var --cloud-opacity) et lance la transition.
            setTimeout(() => {
                cloud.style.opacity = '';
            }, 10);
            // --------------------------------------
        }

        function manageCloudPopulation(targetCount) {
            if (currentCloudCount === targetCount) return;

            // CAS 1 : IL FAUT AJOUTER DES NUAGES
            if (currentCloudCount < targetCount) {
                while (currentCloudCount < targetCount) {
                    createComplexCloud();
                    currentCloudCount++;
                }
            } 
            // CAS 2 : IL FAUT ENLEVER DES NUAGES (Transition douce)
            else if (currentCloudCount > targetCount) {
                // On r√©cup√®re tous les nuages ACTIFS (ceux qui n'ont pas la classe 'dying')
                // Cela √©vite de s√©lectionner ceux qui sont d√©j√† en train de dispara√Ætre
                const clouds = document.querySelectorAll('.cloud:not(.dying)');
                
                while (currentCloudCount > targetCount) {
                    // On prend le dernier de la liste
                    const cloudToRemove = clouds[currentCloudCount - 1];
                    
                    if (cloudToRemove) {
                        // 1. On lui ajoute une classe pour dire "toi, tu meurs bient√¥t"
                        cloudToRemove.classList.add('dying');
                        
                        // 2. On force l'opacit√© √† 0 pour d√©clencher le fondu de sortie
                        cloudToRemove.style.opacity = '0';
                        
                        // 3. On attend 2 secondes (ta dur√©e de transition CSS) avant de le supprimer du DOM
                        setTimeout(() => {
                            cloudToRemove.remove();
                        }, 2000);
                    }
                    currentCloudCount--;
                }
            }
        }

        // ================= 3. PLUIE & NEIGE =================
        const canvas = document.getElementById('weather-canvas');
        const ctx = canvas.getContext('2d');
        let w, h;
        let particles = [];
        let animationId = null;

        function resize(){ w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight; }
        window.onresize=resize; resize();

        class Particle {
            constructor(type) { this.type = type; this.reset(); }
            reset() {
                this.x = Math.random() * w;
                this.y = Math.random() * -h; 
                if (this.type === 'rain') {
                    this.vy = Math.random() * 10 + 10; this.vx = Math.random() * 1 - 0.5; this.len = Math.random() * 20 + 10;
                } else if (this.type === 'snow') {
                    this.vy = Math.random() * 2 + 1; this.vx = Math.random() * 2 - 1; this.size = Math.random() * 3 + 1;
                }
            }
            update() {
                this.y += this.vy; this.x += this.vx; if (this.y > h) this.reset();
            }
            draw() {
                if (this.type === 'rain') {
                    ctx.beginPath(); ctx.strokeStyle = 'rgba(174, 194, 224, 0.5)'; ctx.lineWidth = 1;
                    ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx, this.y + this.len); ctx.stroke();
                } else if (this.type === 'snow') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        function startPrecipitation(type) {
            if (animationId) cancelAnimationFrame(animationId);
            particles = [];
            const count = (type === 'rain') ? 500 : 200; 
            for(let i=0; i<count; i++) particles.push(new Particle(type));
            function loop() {
                ctx.clearRect(0, 0, w, h); particles.forEach(p => { p.update(); p.draw(); });
                animationId = requestAnimationFrame(loop);
            }
            loop();
        }
        function stopPrecipitation() {
            if (animationId) cancelAnimationFrame(animationId);
            ctx.clearRect(0, 0, w, h);
        }

        // ================= 4. DATA CONTROLLER =================
        let isWeatherDebug = false; 
        let debugWindSpeed = 10;    
        let debugWindDir = 270; 

        function applyWeatherData(data) {
            document.getElementById('temp').innerText = Math.round(data.temperature_2m) + "¬∞";
            document.getElementById('icon').innerText = getIcon(data.weather_code, data.is_day);
            document.getElementById('condition').innerText = getDesc(data.weather_code);

            const windS = isWeatherDebug ? debugWindSpeed : data.wind_speed_10m;
            const windD = isWeatherDebug ? debugWindDir : data.wind_direction_10m;
            
            updateDebugDisplay(windS, windD);
            updateWind(windS, windD);
            manageCloudPopulation(getCloudCountFromCode(data.weather_code));
            const root = document.documentElement;
            if ([45, 48].includes(data.weather_code)) {
                // On rend les nuages tr√®s flous et plus transparents
                root.style.setProperty('--cloud-filter', 'blur(25px)'); 
                root.style.setProperty('--cloud-opacity', '0.4');
            } else {
                // Retour √† la normale
                root.style.setProperty('--cloud-filter', 'blur(5px)');
                root.style.setProperty('--cloud-opacity', '0.6');
            }
            const code = data.weather_code;
            stopPrecipitation();
            if ([51,53,55,61,63,65,80,81,82].includes(code)) startPrecipitation('rain');
            else if ([71,73,75,77,85,86].includes(code)) startPrecipitation('snow');
            
            const snowCodes = [71, 73, 75, 85, 86];
            if (snowCodes.includes(code)) {
                root.style.setProperty('--snow-opacity', '1');
            } else  {root.style.setProperty('--snow-opacity', '0')}
        }

        async function updateGlobalWeather() {
            if (isWeatherDebug) return;
            try {
                const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.lat}&longitude=${CONFIG.lon}&current=temperature_2m,is_day,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`);
                const data = await res.json();
                applyWeatherData(data.current);
            } catch (e) { console.error("Erreur M√©t√©o:", e); }
        }

        // --- DEBUG & UTILS ---
        function forceWeather(code) {
            isWeatherDebug = true;
            applyWeatherData({ temperature_2m: 15, is_day: 1, weather_code: code, wind_speed_10m: debugWindSpeed, wind_direction_10m: debugWindDir });
        }
        function forceWindSpeed(val) { debugWindSpeed = parseFloat(val); if (isWeatherDebug) refreshWindOnly(); }
        function forceWindDir(val) { debugWindDir = parseFloat(val); if (isWeatherDebug) refreshWindOnly(); }
        function refreshWindOnly() { updateDebugDisplay(debugWindSpeed, debugWindDir); updateWind(debugWindSpeed, debugWindDir); }
        
        function updateDebugDisplay(speed, dir) {
            document.getElementById('debug-wind-val').innerText = Math.round(speed);
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SO', 'O', 'NO'];
            const index = Math.round(dir / 45) % 8;
            document.getElementById('debug-wind-dir-val').innerText = `${directions[index]} (${Math.round(dir)}¬∞)`;
            if(!isWeatherDebug) {
                document.getElementById('wind-slider').value = speed;
                document.getElementById('wind-dir-slider').value = dir;
            }
        }
        function resetWeatherDebug() { isWeatherDebug = false; document.getElementById('debug-wind-val').innerText = "Auto"; document.getElementById('debug-wind-dir-val').innerText = "Auto"; updateGlobalWeather(); }

        function getCloudCountFromCode(code) {
            // 0 = Ciel Clair
            if (code === 0) return 0;
            
            // 1 = Principalement clair (quelques nuages)
            if (code === 1) return 4;
            
            // 2 = Partiellement nuageux
            if (code === 2) return 20;
            
            // 3 = Couvert (Overcast) -> Beaucoup de nuages pour cacher le ciel
            if (code === 3) return 40;

            // 45, 48 = Brouillard / Brume -> DENSIT√â MAXIMALE
            if ([45, 48].includes(code)) return 150; 
            
            // Pluie / Neige / Orages -> Tr√®s couvert
            if (code >= 51) return 100;
            
            return 5; // Valeur par d√©faut
        }
        function getIcon(code, isDay) { if([0,1].includes(code))return isDay?'‚òÄÔ∏è':'üåô'; if([2,3,45,48].includes(code))return '‚òÅÔ∏è'; if(code>=51&&code<=67)return 'üåßÔ∏è'; if(code>=71)return '‚ùÑÔ∏è'; return 'üå°Ô∏è'; }
        function getDesc(code) {
            // --- CIEL & NUAGES ---
            if (code === 0) return "Ensoleill√©";
            if (code === 1) return "Quelques nuages";
            if (code === 2) return "Partiellement nuageux";
            if (code === 3) return "Couvert";

            // --- BROUILLARD ---
            if (code === 45) return "Brouillard";
            if (code === 48) return "Brouillard givrant";

            // --- BRUINE (Pluie tr√®s fine) ---
            if (code === 51) return "Bruine l√©g√®re";
            if (code === 53) return "Bruine mod√©r√©e";
            if (code === 55) return "Bruine dense";
            if (code === 56 || code === 57) return "Bruine vergla√ßante";

            // --- PLUIE ---
            if (code === 61) return "Pluie faible";
            if (code === 63) return "Pluie mod√©r√©e";
            if (code === 65) return "Pluie forte";
            
            // --- PLUIE VERGLA√áANTE ---
            if (code === 66 || code === 67) return "Pluie vergla√ßante";

            // --- NEIGE ---
            if (code === 71) return "Neige faible";
            if (code === 73) return "Neige mod√©r√©e";
            if (code === 75) return "Forte neige";
            if (code === 77) return "Gr√©sil";

            // --- AVERSES (Pluie courte mais intense) ---
            if (code === 80) return "Averses faibles";
            if (code === 81) return "Averses mod√©r√©es";
            if (code === 82) return "Averses violentes";

            // --- AVERSES DE NEIGE ---
            if (code === 85 || code === 86) return "Averses de neige";

            // --- ORAGES ---
            if (code === 95) return "Orage";
            if (code === 96 || code === 99) return "Orage & Gr√™le";

            return "Ind√©termin√©";
        }
        const slider = document.getElementById('time-slider');
        slider.addEventListener('input', (e) => { simulationOffset = parseFloat(e.target.value); updateAtmosphere(); });
        function resetTime() { simulationOffset = null; document.getElementById('debug-time').innerText = "Temps R√©el"; updateAtmosphere(); }

        updateAtmosphere(); setInterval(updateAtmosphere, 60000); 
        updateGlobalWeather(); setInterval(updateGlobalWeather, 600000); 
        const uiBox =document.querySelector('.ui-container');
        const debugBox=document.querySelector('.debug-panel');
        uiBox.addEventListener('dblclick', () =>{
            debugBox.classList.toggle('visible');
        });
        document.getElementById('scene').addEventListener('click', (e) => {
            if (e.target.id === 'background-sky' || e.target.id === 'scene') {
                debugBox.classList.remove('visible');
            }
        });
    </script>
</body>
</html>